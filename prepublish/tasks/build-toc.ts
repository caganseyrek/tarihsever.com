import fs from "fs";
import path from "path";

import { autogeneratedComment } from "@/prepublish/common/node-data";
import { ARTICLE_FILE_EXT, HEADING_REGEX } from "@/prepublish/common/node-utils";

import { slugify } from "@/shared/utils";

import type { HeadingNodeProps, HeadingProps } from "@/types/globals";

class TOCBuilder {
  public static build(articleFullPath: string): void {
    const articleDirectory: string = path.dirname(articleFullPath);
    const articleFileBaseName: string = path.basename(articleFullPath, ARTICLE_FILE_EXT);
    const articleTocFilePath: string = path.join(articleDirectory, `${articleFileBaseName}.toc.ts`);

    // Read the file contents as string
    const fileContent: string = fs.readFileSync(articleFullPath, "utf8");

    const headings: HeadingProps[] = this.extractAndParseHeadings(fileContent);
    const generatedNodes: HeadingNodeProps[] = this.generateNodes(headings);

    const tocFileContent: string = `${autogeneratedComment}
import type { HeadingNodeProps } from "@/types/globals";

export const toc: HeadingNodeProps[] = ${JSON.stringify(generatedNodes, null, 2)};\n`;

    // Save the update file contents
    fs.writeFileSync(articleTocFilePath, tocFileContent, "utf8");
  }

  private static extractAndParseHeadings(fileContent: string): HeadingProps[] {
    // Split the content string from the '\n' characters then filter the resulting array
    // to only include the elements that starts with # (headings)
    const extractedHeadings: string[] = fileContent.split("\n").filter((token) => token.startsWith("#"));
    const parsedHeadings: HeadingProps[] = [];

    extractedHeadings.forEach((heading) => {
      const match: RegExpMatchArray | null = HEADING_REGEX.exec(heading);
      if (match) {
        // Get the heading level from the number of #s
        const level: number = match[1].length;

        // Get the text of the heading
        const text: string = match[2].trim();

        // Add the heading details into the headings array
        parsedHeadings.push({ level: level, text: text });
      }
    });
    return parsedHeadings;
  }

  private static generateNodes(parsedHeadings: HeadingProps[]): HeadingNodeProps[] {
    const generatedNodes: HeadingNodeProps[] = [];
    const stack: HeadingNodeProps[] = [];

    for (const heading of parsedHeadings) {
      const node: HeadingNodeProps = {
        id: slugify(heading.text),
        text: heading.text,
        level: heading.level,
        children: [],
      };
      // Loop to pop elements from the stack while their level is greater than
      // or equal to the current heading's level
      while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
        stack.pop();
      }
      // Skip h1 headings, as they are reserved for the main page title
      if (heading.level === 1) continue;

      // If the stack is empty, it means the node is at the top level,
      // so we add it to the 'generatedNodes' array
      if (stack.length === 0) {
        generatedNodes.push(node);
      } else {
        // Otherwise, it is a child of the last node in the stack, so we push it as a child
        stack[stack.length - 1].children.push(node);
      }
      stack.push(node);
    }
    return generatedNodes;
  }
}

export { TOCBuilder };
